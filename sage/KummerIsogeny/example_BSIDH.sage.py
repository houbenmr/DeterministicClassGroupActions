"""
Implementation of BSIDH https://ia.cr/2019/1145
to test the Kummer Line isogenies and compare timings
"""


# This file was *autogenerated* from the file example_BSIDH.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0x1935BECE108DC6C0AAD0712181BB1A414E6A8AAA6B510FC29826190FE7EDA80F = Integer(0x1935BECE108DC6C0AAD0712181BB1A414E6A8AAA6B510FC29826190FE7EDA80F); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_9 = Integer(9); _sage_const_31 = Integer(31); _sage_const_8 = Integer(8); _sage_const_311 = Integer(311); _sage_const_571 = Integer(571); _sage_const_1321 = Integer(1321); _sage_const_5119 = Integer(5119); _sage_const_6011 = Integer(6011); _sage_const_14207 = Integer(14207); _sage_const_28477 = Integer(28477); _sage_const_76667 = Integer(76667); _sage_const_11 = Integer(11); _sage_const_18 = Integer(18); _sage_const_19 = Integer(19); _sage_const_23 = Integer(23); _sage_const_13 = Integer(13); _sage_const_47 = Integer(47); _sage_const_79 = Integer(79); _sage_const_83 = Integer(83); _sage_const_89 = Integer(89); _sage_const_151 = Integer(151); _sage_const_3347 = Integer(3347); _sage_const_17449 = Integer(17449); _sage_const_33461 = Integer(33461); _sage_const_51193 = Integer(51193); _sage_const_0x76042798BBFB78AEBD02490BD2635DEC131ABFFFFFFFFFFFFFFFFFFFFFFFFFFF = Integer(0x76042798BBFB78AEBD02490BD2635DEC131ABFFFFFFFFFFFFFFFFFFFFFFFFFFF); _sage_const_110 = Integer(110); _sage_const_5 = Integer(5); _sage_const_67 = Integer(67); _sage_const_223 = Integer(223); _sage_const_4229 = Integer(4229); _sage_const_9787 = Integer(9787); _sage_const_13399 = Integer(13399); _sage_const_21521 = Integer(21521); _sage_const_32257 = Integer(32257); _sage_const_47353 = Integer(47353); _sage_const_34 = Integer(34); _sage_const_29 = Integer(29); _sage_const_37 = Integer(37); _sage_const_53 = Integer(53); _sage_const_97 = Integer(97); _sage_const_107 = Integer(107); _sage_const_109 = Integer(109); _sage_const_131 = Integer(131); _sage_const_137 = Integer(137); _sage_const_197 = Integer(197); _sage_const_199 = Integer(199); _sage_const_227 = Integer(227); _sage_const_251 = Integer(251); _sage_const_5519 = Integer(5519); _sage_const_9091 = Integer(9091); _sage_const_33997 = Integer(33997); _sage_const_38201 = Integer(38201); _sage_const_0 = Integer(0)
# Python imports
import time 
import sys

# Local imports
from kummer_line import KummerLine
from kummer_isogeny import KummerLineIsogeny
from utilities import compute_quadratic_twist, fix_even_torsion
from benchmark_utils import compare_isogeny

# ============================== #
#     B-SIDH parameter setup     #
# ============================== #

# Set which parameter set to use
# Default is example three
PARAM = "THREE"
for arg in sys.argv[_sage_const_1 :]:
    if arg.lower() in ["--two"]:
        PARAM = "TWO"

if PARAM == "TWO":
    # p + 1 = 2^4 * 3 * 7^16 * 17^9 * 31^8 * 311 * 571 * 1321 * 5119 * 6011 * 14207 * 28477 * 76667 * 315668179
    # p - 1 = 2 * 11^18 * 19 * 23^13 * 47 * 79 * 83 * 89 * 151 * 3347 * 17449 * 33461 * 51193 * 258434945441
    p = _sage_const_0x1935BECE108DC6C0AAD0712181BB1A414E6A8AAA6B510FC29826190FE7EDA80F 
    A_torsion = _sage_const_2 **_sage_const_4  * _sage_const_3  * _sage_const_7 **_sage_const_16  * _sage_const_17 **_sage_const_9  * _sage_const_31 **_sage_const_8  * _sage_const_311  * _sage_const_571  * _sage_const_1321  * _sage_const_5119  * _sage_const_6011  * _sage_const_14207  * _sage_const_28477  * _sage_const_76667 
    A_cofactor = (p+_sage_const_1 ) // A_torsion
    B_torsion = _sage_const_11 **_sage_const_18  * _sage_const_19  * _sage_const_23 **_sage_const_13  * _sage_const_47  * _sage_const_79  * _sage_const_83  * _sage_const_89  * _sage_const_151  * _sage_const_3347  * _sage_const_17449  * _sage_const_33461  * _sage_const_51193 
    B_cofactor = (p-_sage_const_1 ) // B_torsion
else:
    # Example 3 from BSIDH
    # p + 1 = 2^110 * 5 * 7^2 * 67 * 223 * 4229 * 9787 * 13399 * 21521 * 32257 * 47353 * 616228535059
    # p - 1 = 2 * 3^34 * 11 * 17 * 19^2 * 29 * 37 * 53^2 * 97 * 107 * 109 * 131 * 137 * 197 * 199 * 227 * 251 * 5519 * 9091 * 33997 * 38201 * 460409 * 5781011
    p = _sage_const_0x76042798BBFB78AEBD02490BD2635DEC131ABFFFFFFFFFFFFFFFFFFFFFFFFFFF 
    A_torsion = _sage_const_2 **_sage_const_110  * _sage_const_5  * _sage_const_7 **_sage_const_2  * _sage_const_67  * _sage_const_223  * _sage_const_4229  * _sage_const_9787  * _sage_const_13399  * _sage_const_21521  * _sage_const_32257  * _sage_const_47353 
    A_cofactor = (p+_sage_const_1 ) // A_torsion
    B_torsion = _sage_const_3 **_sage_const_34  * _sage_const_11  * _sage_const_17  * _sage_const_19 **_sage_const_2  * _sage_const_29  * _sage_const_37  * _sage_const_53 **_sage_const_2  * _sage_const_97  * _sage_const_107  * _sage_const_109  * _sage_const_131  * _sage_const_137  * _sage_const_197  * _sage_const_199  * _sage_const_227  * _sage_const_251  * _sage_const_5519  * _sage_const_9091  * _sage_const_33997  * _sage_const_38201 
    B_cofactor = (p-_sage_const_1 ) // B_torsion

# We need our isogenies to be coprime
# for the protocol to work
assert gcd(A_torsion, B_torsion) == _sage_const_1 

# Construct the base-field and elliptic curve
Fp2 = GF(p**_sage_const_2 , names=('z2',)); (z2,) = Fp2._first_ngens(1)
E0 = EllipticCurve(Fp2, [_sage_const_1 ,_sage_const_0 ])
E0.set_order((p + _sage_const_1 )**_sage_const_2 )
assert E0.is_supersingular()

# Compute the quadratic twist of E0 for torsion
# generation
D_twist, E0t = compute_quadratic_twist(E0)

# ============================== #
#      B-SIDH parameter gen.     #
# ============================== #

# Compute points on E0 and E0t with order 
# A_torsion and B_torsion
PA, QA = [A_cofactor*X for X in E0.gens()]
PB, QB = [B_cofactor*X for X in E0t.gens()]
# Ensure that 2^(b-1) * Q = (0,0) to 
# stop the kernel ever being the point (0,0)
PA, QA = fix_even_torsion(PA, QA)
PB, QB = fix_even_torsion(PB, QB, twist=True)

# Represent x-coordinate on the Kummer line of
# E0
L = KummerLine(E0)

# Points in the A torsion are on E0
A_torsion_data = [L(X) for X in (PA, QA, PA-QA)]

# Points in the B torsion are on E0_twist, so we map
# the x-coords back to E0 (y will be irrational but
# Kummer Line doesn't care).
B_torsion_data = [L(D_twist * X[_sage_const_0 ]) for X in (PB, QB, PB-QB)]

# Check orders of x-only points
assert (A_torsion * A_torsion_data[_sage_const_0 ]).is_zero()
assert (A_torsion * A_torsion_data[_sage_const_1 ]).is_zero()
assert (B_torsion * B_torsion_data[_sage_const_0 ]).is_zero()
assert (B_torsion * B_torsion_data[_sage_const_1 ]).is_zero()

# ========================================== #
#        BSIDH: https://ia.cr/2019/1145      #
# ========================================== #

def keygen(torsion_data, other_torsion_data, order):
    """
    BSIDH KeyGen following https://ia.cr/2019/1145
    """
    # Unpack torsion
    xP, xQ, xPQ = torsion_data
    xP_other, xQ_other, xPQ_other = other_torsion_data

    # Secret values
    sk = randint(_sage_const_0 , order)
    xG = xQ.ladder_3_pt(xP, xPQ, sk)
    phi = KummerLineIsogeny(xG.parent(), xG, order)

    # Public Key
    E = phi.codomain()
    imxP, imxQ, imxPQ = [phi(X) for X in (xP_other, xQ_other, xPQ_other)]
    pk = (E, imxP, imxQ, imxPQ)

    return sk, pk

def shared_secret(sk, pk_other, order):
    """
    BSIDH Shared Secret generation following https://ia.cr/2019/1145
    """
    # Unpack pk
    K, xP, xQ, xPQ = pk_other

    # Compute shared curve
    xK = xQ.ladder_3_pt(xP, xPQ, sk)
    psi = KummerLineIsogeny(K, xK, order)
    return psi.codomain().j_invariant()


# ============================== #
#        Time the Protocol       #
# ============================== #

t0 = time.time()
skA, pkA = keygen(A_torsion_data, B_torsion_data, A_torsion)
print(f"Keygen A took: {time.time() - t0}")

t0 = time.time()
skB, pkB = keygen(B_torsion_data, A_torsion_data, B_torsion)
print(f"Keygen B took: {time.time() - t0}")

t0 = time.time()
sA = shared_secret(skA, pkB, A_torsion)
print(f"Secret A took: {time.time() - t0}")

t0 = time.time()
sB = shared_secret(skB, pkA, B_torsion)
print(f"Secret B took: {time.time() - t0}")

assert sA == sB

# Compare isogeny timings for p+1 torsion and p-1 torsion
xPA, xQA, _ = A_torsion_data
xPB, xQB, _ = B_torsion_data
compare_isogeny(PA, QA, xPA, xQA, A_torsion)
compare_isogeny(PB, QB, xPB, xQB, B_torsion)


